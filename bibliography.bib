
@inproceedings{buckland_open_2015,
	location = {New York, {NY}, {USA}},
	title = {Open Access to Working Notes in the Humanities},
	isbn = {978-1-4503-3666-6},
	url = {http://doi.acm.org/10.1145/2788993.2789852},
	doi = {10.1145/2788993.2789852},
	series = {{OpenSym} '15},
	abstract = {A web-based tool for making and sharing research designed for authors, curators, and editors in the humanities is described, {\textless}u{\textgreater}editorsnotes.org{\textless}/u{\textgreater}. Notes are a varied genre not limited to annotations. The data for the tool is modeled as three kinds of records: Notes created; Documents cited; and Topics, headings for names and subjects. Structured records are needed for interoperability and sharing. Open access, sustainability issues, and how working notes can complement other infrastructure are discussed in a status report.},
	pages = {11:1--11:4},
	booktitle = {Proceedings of the 11th International Symposium on Open Collaboration},
	publisher = {{ACM}},
	author = {Buckland, Michael K. and Golden, Patrick and Shaw, Ryan B.},
	urldate = {2015-12-11},
	date = {2015},
	keywords = {documentary editions, editors, historians, working notes},
	file = {ACM Full Text PDF:/Users/michaelhilton/Library/Application Support/Zotero/Profiles/f67bsoxk.default/zotero/storage/XKAHK32G/Buckland et al. - 2015 - Open Access to Working Notes in the Humanities.pdf:application/pdf}
}

@inproceedings{garlan_gnome:_1984,
	location = {New York, {NY}, {USA}},
	title = {{GNOME}: An Introductory Programming Environment Based on a Family of Structure Editors},
	isbn = {0-89791-131-8},
	url = {http://doi.acm.org/10.1145/800020.808250},
	doi = {10.1145/800020.808250},
	series = {{SDE} 1},
	shorttitle = {{GNOME}},
	abstract = {Structure editors have frequently been used as powerful and unifying interfaces for programming environments in computer science research settings. Few, however, have found their way into common use. {GNOME} is an attempt to channel the experience gained in the use of structure editing for software development environment research of the Gandalf Project into a practical novice programming environment. Based on a family of structure editors, it is currently being used to teach programming to undergraduates at Carnegie-Mellon University. This paper describes the {GNOME} environment, recounts lessons learned in adapting structure editors to novice programmers, and discusses its effectiveness as a teaching environment.},
	pages = {65--72},
	booktitle = {Proceedings of the First {ACM} {SIGSOFT}/{SIGPLAN} Software Engineering Symposium on Practical Software Development Environments},
	publisher = {{ACM}},
	author = {Garlan, David B. and Miller, Philip L.},
	urldate = {2015-12-11},
	date = {1984},
	file = {ACM Full Text PDF:/Users/michaelhilton/Library/Application Support/Zotero/Profiles/f67bsoxk.default/zotero/storage/3F93F35M/Garlan and Miller - 1984 - GNOME An Introductory Programming Environment Bas.pdf:application/pdf}
}

@inproceedings{ko_barista:_2006,
	location = {New York, {NY}, {USA}},
	title = {Barista: An Implementation Framework for Enabling New Tools, Interaction Techniques and Views in Code Editors},
	isbn = {1-59593-372-7},
	url = {http://doi.acm.org/10.1145/1124772.1124831},
	doi = {10.1145/1124772.1124831},
	series = {{CHI} '06},
	shorttitle = {Barista},
	abstract = {Recent advances in programming environments have focused on improving programmer productivity by utilizing the inherent structure in computer programs. However, because these environments represent code as plain text, it is difficult and sometimes impossible to embed interactive tools, annotations, and alternative views in the code itself. Barista is an implementation framework that enables the creation of such user interfaces by simplifying the implementation of editors that represent code internally as an abstract syntax tree and maintain a corresponding, fully structured visual representation on-screen. Barista also provides designers of editors with a standard text-editing interaction technique that closely mimics that of conventional text editors, overcoming a central usability issue of previous structured code editors.},
	pages = {387--396},
	booktitle = {Proceedings of the {SIGCHI} Conference on Human Factors in Computing Systems},
	publisher = {{ACM}},
	author = {Ko, Andrew J. and Myers, Brad A.},
	urldate = {2015-12-11},
	date = {2006},
	keywords = {end-user software engineering, programming environments, structured editors},
	file = {ACM Full Text PDF:/Users/michaelhilton/Library/Application Support/Zotero/Profiles/f67bsoxk.default/zotero/storage/UNAR5UQC/Ko and Myers - 2006 - Barista An Implementation Framework for Enabling .pdf:application/pdf}
}

@inproceedings{oney_codelets:_2012,
	location = {New York, {NY}, {USA}},
	title = {Codelets: Linking Interactive Documentation and Example Code in the Editor},
	isbn = {978-1-4503-1015-4},
	url = {http://doi.acm.org/10.1145/2207676.2208664},
	doi = {10.1145/2207676.2208664},
	series = {{CHI} '12},
	shorttitle = {Codelets},
	abstract = {Programmers frequently use instructive code examples found on the Web to overcome cognitive barriers while programming. These examples couple the concrete functionality of code with rich contextual information about how the code works. However, using these examples necessitates understanding, configuring, and integrating the code, all of which typically take place after the example enters the user's code and has been removed from its original instructive context. In short, a user's interaction with an example continues well after the code is pasted. This paper investigates whether treating examples as "first-class" objects in the code editor - rather than simply as strings of text - will allow programmers to use examples more effectively. We explore this through the creation and evaluation of Codelets. A Codelet is presented inline with the user's code, and consists of a block of example code and an interactive helper widget that assists the user in understanding and integrating the example. The Codelet persists throughout the example's lifecycle, remaining accessible even after configuration and integration is done. A comparative laboratory study with 20 participants found that programmers were able to complete tasks involving examples an average of 43\% faster when using Codelets than when using a standard Web browser.},
	pages = {2697--2706},
	booktitle = {Proceedings of the {SIGCHI} Conference on Human Factors in Computing Systems},
	publisher = {{ACM}},
	author = {Oney, Stephen and Brandt, Joel},
	urldate = {2015-12-11},
	date = {2012},
	keywords = {Documentation, example, Programming, structured editing},
	file = {ACM Full Text PDF:/Users/michaelhilton/Library/Application Support/Zotero/Profiles/f67bsoxk.default/zotero/storage/3FAU6US9/Oney and Brandt - 2012 - Codelets Linking Interactive Documentation and Ex.pdf:application/pdf}
}

@inproceedings{mendes_structure_2014,
	location = {New York, {NY}, {USA}},
	title = {Structure Editing of Handwritten Mathematics: Improving the Computer Support for the Calculational Method},
	isbn = {978-1-4503-2587-5},
	url = {http://doi.acm.org/10.1145/2669485.2669495},
	doi = {10.1145/2669485.2669495},
	series = {{ITS} '14},
	shorttitle = {Structure Editing of Handwritten Mathematics},
	abstract = {We present a structure editor that aims to facilitate the presentation and manipulation of handwritten mathematical expressions. The editor is oriented to the calculational mathematics involved in algorithmic problem solving and it provides features that allow reliable structure manipulation of mathematical formulae, as well as flexible and interactive presentations. We describe some of its most important features, including the use of gestures to manipulate algebraic formulae, the structured selection of expressions, definition and redefinition of operators in runtime, gesture's editor, and handwritten templates. The editor is made available in the form of a C\# class library which can be easily used to extend existing tools. For example, we have extended Classroom Presenter, a tool for ink-based teaching presentations and classroom interaction. We have tested and evaluated the editor with target users. The results obtained seem to indicate that the software is usable, suitable for its purpose and a valuable contribution to teaching and learning algorithmic problem solving.},
	pages = {139--148},
	booktitle = {Proceedings of the Ninth {ACM} International Conference on Interactive Tabletops and Surfaces},
	publisher = {{ACM}},
	author = {Mendes, Alexandra and Backhouse, Roland and Ferreira, Joao F.},
	urldate = {2015-12-11},
	date = {2014},
	keywords = {calculational method, c\# class library, computer science education, Gestures, handwritten mathematics, mathematics education, structure editor, tablet pcs},
	file = {ACM Full Text PDF:/Users/michaelhilton/Library/Application Support/Zotero/Profiles/f67bsoxk.default/zotero/storage/RQKVBK5E/Mendes et al. - 2014 - Structure Editing of Handwritten Mathematics Impr.pdf:application/pdf}
}

@inproceedings{voelter_mbeddr:_2012,
	location = {New York, {NY}, {USA}},
	title = {Mbeddr: An Extensible C-based Programming Language and {IDE} for Embedded Systems},
	isbn = {978-1-4503-1563-0},
	url = {http://doi.acm.org/10.1145/2384716.2384767},
	doi = {10.1145/2384716.2384767},
	series = {{SPLASH} '12},
	shorttitle = {Mbeddr},
	abstract = {While the C programming language provides good support for writing efficient, low-level code, it is not adequate for defining higher-level abstractions relevant to embedded software. In this paper we present the mbeddr technology stack that supports extension of C with constructs adequate for embedded systems. In mbeddr, efficient low-level programs can be written using the well-known concepts from C. Higher-level domain-specific abstractions can be seamlessly integrated into C by means of modular language extension regarding syntax, type system, semantics and {IDE}. In the paper we show how language extension can address the challenges of embedded software development and report on our experience in building these extensions. We show that language workbenches deliver on the promise of significantly reducing the effort of language engineering and the construction of corresponding {IDEs}. mbeddr is built on top of the {JetBrains} {MPS} language workbench. Both {MPS} and mbeddr are open source software.},
	pages = {121--140},
	booktitle = {Proceedings of the 3rd Annual Conference on Systems, Programming, and Applications: Software for Humanity},
	publisher = {{ACM}},
	author = {Voelter, Markus and Ratiu, Daniel and Schaetz, Bernhard and Kolb, Bernd},
	urldate = {2015-12-11},
	date = {2012},
	keywords = {development environments, dsls, embedded software, formal methods, language extension},
	file = {ACM Full Text PDF:/Users/michaelhilton/Library/Application Support/Zotero/Profiles/f67bsoxk.default/zotero/storage/F7MAMK5T/Voelter et al. - 2012 - Mbeddr An Extensible C-based Programming Language.pdf:application/pdf}
}

@article{teitelbaum_cornell_1981,
	title = {The Cornell Program Synthesizer: A Syntax-directed Programming Environment},
	volume = {24},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/358746.358755},
	doi = {10.1145/358746.358755},
	shorttitle = {The Cornell Program Synthesizer},
	abstract = {Programs are not text; they are hierarchical compositions of computational structures and should be edited, executed, and debugged in an environment that consistently acknowledges and reinforces this viewpoint. The Cornell Program Synthesizer demands a structural perspective at all stages of program development. Its separate features are unified by a common foundation: a grammar for the programming language. Its full-screen derivation-tree editor and syntax-directed diagnostic interpreter combine to make the Synthesizer a powerful and responsive interactive programming tool.},
	pages = {563--573},
	number = {9},
	journaltitle = {Commun. {ACM}},
	author = {Teitelbaum, Tim and Reps, Thomas},
	urldate = {2015-12-11},
	date = {1981-09},
	keywords = {diagnostic interpreter, program development system, programming environment, source language debugger, syntax-directed editor, template},
	file = {ACM Full Text PDF:/Users/michaelhilton/Library/Application Support/Zotero/Profiles/f67bsoxk.default/zotero/storage/E7E68F7N/Teitelbaum and Reps - 1981 - The Cornell Program Synthesizer A Syntax-directed.pdf:application/pdf}
}

@inproceedings{tillmann_touchdevelop:_2011,
	location = {New York, {NY}, {USA}},
	title = {{TouchDevelop}: Programming Cloud-connected Mobile Devices via Touchscreen},
	isbn = {978-1-4503-0941-7},
	url = {http://doi.acm.org/10.1145/2048237.2048245},
	doi = {10.1145/2048237.2048245},
	series = {Onward! 2011},
	shorttitle = {{TouchDevelop}},
	abstract = {The world is experiencing a technology shift. In 2011, more touchscreen-based mobile devices like smartphones and tablets will be sold than desktops, laptops, and netbooks combined. In fact, in many cases incredibly powerful and easy-to-use smart phones are going to be the first and, in less developed countries, possibly the only computing devices which virtually all people will own, and carry with them at all times. Furthermore, mobile devices do not only have touchscreens, but they are also equipped with a multitude of sensors, such as location information and acceleration, and they are always connected to the cloud. {TouchDevelop} is a novel application creation environment for anyone to script their smartphones anywhere -- you do not need a separate {PC}. {TouchDevelop} allows you to develop mobile device applications that can access your data, your media, your sensors and allows using cloud services including storage, computing, and social networks. {TouchDevelop} targets students, and hobbyists, not necessarily the professional developer. Typical {TouchDevelop} applications are written for fun, or for personalizing the phone. {TouchDevelop}'s typed, structured programming language is built around the idea of only using a touchscreen as the input device to author code. It has built-in primitives which make it easy to access the rich sensor data available on a mobile device. In our vision, the state of the program is automatically distributed between mobile clients and the cloud, with automatic synchronization of data and execution between clients and cloud, liberating the programmer from worrying (or even having to know about) the details. We report on our experience with our first prototype implementation for the Windows Phone 7 platform, which already realizes a large portion of our vision. It is available on the Windows Phone Marketplace.},
	pages = {49--60},
	booktitle = {Proceedings of the 10th {SIGPLAN} Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
	publisher = {{ACM}},
	author = {Tillmann, Nikolai and Moskal, Michal and de Halleux, Jonathan and Fahndrich, Manuel},
	urldate = {2015-12-11},
	date = {2011},
	keywords = {cloud, mobile devices, touchscreen, type inference},
	file = {ACM Full Text PDF:/Users/michaelhilton/Library/Application Support/Zotero/Profiles/f67bsoxk.default/zotero/storage/MWXSXG6A/Tillmann et al. - 2011 - TouchDevelop Programming Cloud-connected Mobile D.pdf:application/pdf}
}